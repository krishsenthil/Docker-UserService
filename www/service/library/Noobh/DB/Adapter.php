<?php

/**
 * Noobh Framework
 *
 * Collash Inc Internal
 *
 * Database ineraction is an expensive operation and for performence reasons
 * all the Database related classes are wrapped into this single file. This
 * is a place where are breaking the framework convension for some performence
 * gain
 *
 * @category   Framework
 * @package    Noobh
 * @subpackage Noobh_DB
 * @copyright  Copyright (c) Collash Inc
 * @version    0.1
 * @license    Collash Inc
 */
/**
 *
 *
 * Collash Inc Internal
 *
 * Abstracts all the basic database applications
 * to a single location. Like datbase connection, fetch modes
 * query profeling etc
 *
 * Supported list of Drivers:
 * 
 *   1. Mysqli
 *   2. PDO (Mysqli alone for now)
 *
 * @todo :
 *      
 *       1. Persistent Connections
 *       2. Fetch Mode
 *      
 *       This class should be extened to different database adapters
 *       like MYSQL, DB2 etc
 *      
 *      
 * @author Vijay <vbose@Collash.com>
 * @copyright Collash Inc
 * @package Noobh_DB
 * @since 0.1
 *        @date Aug 28, 2012
 */
abstract class Noobh_Db_Abstract
{

    /**
     * Default port for mysqli driver if no other
     * ports are assigned
     * @var {integer}
     */
    const DEFAULT_MYSQL_PORT = '3306';
    const DRIVER_MYSQLI = 'mysqli';
    const DRIVER_PDO_MYSQLI = 'pdo_mysqli';
    
    /**
     * Store statement
     * @var string
     */
    protected $_stmt = null;
    /**
     * List of drivers supported by Noobh Adapter
     *
     * Mysqli is already present in PDO, but for backward
     * compactibility we are supporting PDO and mysqli seperatly
     *
     * @var {array}
     */
    protected $_supportedDrivers = array('mysqli', 'pdo_mysqli');

    /**
     * User-provided configuration
     *
     * @var array
     */
    protected $_config = array();

    /**
     * Database connection
     *
     * @var object resource null
     */
    protected $_connection = null;

    /**
     * Default active drive is mysqli
     * You can set it pdo,mysql etc
     * 
     * @var {string}
     */
    protected $_activeDriver = 'mysqli';

    /**
     * Specifies whether the adapter automatically quotes identifiers.
     * If true, most SQL generated by classes applies
     * identifier quoting automatically.
     * If false, developer must quote identifiers themselves
     * by calling quoteIdentifier().
     *
     * @var bool
     */
    protected $_autoQuoteIdentifiers = true;

    /**
     * Constructor.
     *
     * $config is an array of key/value pairs or an instance of Noobh_Config
     * containing configuration options. These options are common to most
     * adapters:
     *
     * dbname => (string) The name of the database to user
     * username => (string) Connect to the database as this username.
     * password => (string) Password associated with the username.
     * host => (string) What host to connect to, defaults to localhost
     *
     * Some options are used on a case-by-case basis by adapters:
     *
     * port => (string) The port of the database
     * persistent => (boolean) Whether to use a persistent connection or not,
     * defaults to false
     * protocol => (string) The network protocol, defaults to TCPIP
     *
     * @param array|Noobh_Config $config
     *            An array or instance of Noobh_Config having configuration
     *            data
     * @throws Exception
     */
    public function __construct ($config = null)
    {
        // Fallback logic for config file
        if ($config == NULL) {
            $config = Noobh_Config::getInstance();
            if (isset($config['resource']['db'])) {
                // Check database connection type - default to mysqli
                if (! isset($config['resource']['db']['adapter'])) {
                    $config['resource']['db']['adapter'] = $this->_activeDriver;
                } else {
                    $this->_activeDriver = $config['resource']['db']['adapter'];
                }
                $config = $config['resource']['db']['param'];
            } else {
                throw new Exception(
                        'Empty database configuration supplied to DB Adapter');
            }
        }
        
        /**
         * Verify that adapter parameters are in an array.
         * 
         * @todo : Will be supporting object in future.Currently
         *       Noobh_Config returns array so the following code is not
         *       accessed at any point of execution
         */
        if (! is_array($config)) {
            /*
             * Convert Noobh_Config argument to a plain array.
             */
            if ($config instanceof Noobh_Config) {
                $config = $config->toArray();
            } else {
                throw new Exception(
                        'Adapter parameters must be in an array or a Noobh_Config object');
            }
        }
        
        $this->_checkRequiredOptions($config);
        
        // To override connection charecter set
        if (! isset($config['charset'])) {
            $config['charset'] = null;
        }
        
        // @todo: Need to be used for persistent connections and database
        // pooling
        if (! isset($config['persistent'])) {
            $config['persistent'] = false;
        }
        
        $this->_config = array_merge($this->_config, $config);
    }
    
    /**
     * Clear all loaded objects
     * @access public
     * @param void
     * @return void
     */
    public function __destruct(){
        //Clear memory
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            if(!empty($this->_stmt)){
                $this->_stmt->free_result();
                $this->closeConnection();
            }    
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            $this->closeConnection();
        }
    }
    
    /**
     * Check for config options that are mandatory.
     * Throw exceptions if any are missing.
     *
     * @param array $config
     * @throws Exception
     */
    protected function _checkRequiredOptions (array $config)
    {
        // we need at least a dbname
        if (! array_key_exists('dbname', $config)) {
            throw new Exception(
                    "Configuration array must have a key for 'dbname' that names the database instance");
        }
    
        if (! array_key_exists('password', $config)) {
            throw new Exception(
                    "Configuration array must have a key for 'password' for login credentials");
        }
    
        if (! array_key_exists('username', $config)) {
            throw new Exception(
                    "Configuration array must have a key for 'username' for login credentials");
        }
    }
    /**
     * List all supported database drivers
     *
     * This is just a handy method for information which
     * will retrun the same list of drivers
     *
     * @access public
     * @param
     *            void
     * @return {array}
     */
    public static function supportedDrivers ()
    {
        return array('mysqli', 'pdo_mysqli');
    }

    /**
     * Get active driver
     *
     * @access public
     * @param void
     * @return {sting}
     */
    public function getActiveDriver ()
    {
        return $this->_activeDriver;
    }
    
    /**
     * Set active driver
     *
     * @access public
     * @param {sting} $driver
     * @return void
     */
    public function setActiveDriver ($driver)
    {
        if(in_array($driver, $this->_supportedDrivers)){
            $this->_activeDriver = $driver;
        }else{
            throw new Exception ("Supprlied driver is not supported by Noobh Framework");
        }
    }
    
    /**
     * Returns the underlying database connection object or resource.
     * If not presently connected, this initiates the connection.
     *
     * @return object resource null
     */
    public function getConnection ()
    {
        $this->_connect();
        return $this->_connection;
    }

    /**
     * Returns the configuration variables in this adapter.
     *
     * @return array
     */
    public function getConfig ()
    {
        return $this->_config;
    }

    /**
     * Prepares and executes an SQL statement with bound data.
     *
     * @param mixed $sql
     *            The SQL statement with placeholders.
     * @param mixed $bind
     *            An array of data to bind to the placeholders.
     * @return 
     */
    public function query ($sql, $bind = array())
    {
        // prepare and execute the statement with profiling
        $this->prepare($sql);
        $this->execute($bind);
        return $this;
    }

    /**
     * Prepare a statement and return a PDOStatement-like object.
     *
     * @param
     *            string query
     * @return PDOStatement
     */
    abstract public function prepare ($sql);
    
    /**
     * Force the connection to close.
     *
     * @return void
     */
    abstract public function closeConnection ();
}

/**
 *
 *
 * Collash Inc Internal
 *
 *
 * This is an adapter class which abstract database from application. After
 * passing the config params the connection and quering process are taken care
 * by this
 * class. We can make connection to any type of Database from this class and the
 * application
 * will not be aware about the database to which it is connected
 *
 * Currently we are supporting only Mysqli and PDO at any point of time if we
 * are
 * supporting or using any other type of database we can change this class and
 * use this
 * as a factory class and switch between different database adapters
 *
 * Noobh Global Libraray is having caching logic and datbase connection, this
 * class is using
 * the same class for databse connection which can be modified at any point of
 * time.
 *
 *
 * Supports basic SQL statements like Insert,Delete,Update,Select. You can also
 * use raw sql
 * directly. Errors from will be thrown back to the caller from as it is from
 * Mysql. Exceptions
 * are not wrapped in this class
 *
 *
 * @todo : Need to optimize this class by using connection pool, Need to enhance
 *       couple of methods
 *      
 *       Due to overhead issues we avoid using DataMappers and Repository
 *       Pattern and following the
 *       simple approach to create database connection and quering it. Total
 *       nature of applications running
 *       in Noobh seems to be using less volume of data and manipulations.
 *      
 *      
 *       For switching between different drivers we need to write extra wrapper
 *       classes for mysqli, pdo etc.
 *       But for performence opimization we are using this same class for
 *       switching between the drivers and
 *       wrapping driver object
 *      
 *      
 * @author Vijay <vbose@Collash.com>
 * @copyright Collash Inc
 * @package Noobh_DB
 * @since 0.1
 *        @date Mar 28, 2012
 */
class Noobh_DB_Adapter extends Noobh_Db_Abstract
{
    /**
     * SQL string split into an array at placeholders.
     *
     * @var array
     */
    protected $_sqlSplit = array();

    /**
     * Parameter placeholders in the SQL string by position in the split array.
     *
     * @var array
     */
    protected $_sqlParam = array();

    /**
     * Attributes.
     *
     * @var array
     */
    protected $_attribute = array();

    /**
     * Column result bindings.
     *
     * @var array
     */
    protected $_bindColumn = array();

    /**
     * Query parameter bindings; covers bindParam() and bindValue().
     *
     * @var array
     */
    protected $_bindParam = array();

    /**
     *
     * @var array
     */
    protected $_meta = null;

    /**
     * Column names.
     *
     * @var array
     */
    protected $_keys;

    /**
     * Fetched result values.
     *
     * @var array
     */
    protected $_values;

    /**
     * Connect to mysqli driver.
     * Check for mysqli extenstion
     * and connect to driver using database params
     *
     * @access private
     * @param
     *            void
     * @return void
     * @throws Exception
     */
    private function _connectMysqliDriver ()
    {
        if (! extension_loaded('mysqli')) {
            throw new Exception(
                    'The Mysqli extension is required for this adapter but the extension is not loaded');
        }
        
        // connect to database
        ! empty($this->_config['socket']) ? $socket = $this->_config['socket'] : $socket = null;
        
        if (isset($this->_config['port'])) {
            $port = (integer) $this->_config['port'];
        } else {
            $port = self::DEFAULT_MYSQL_PORT;
        }
        
        $this->_connection = mysqli_init();
        
        if (! empty($this->_config['driver_options'])) {
            foreach ($this->_config['driver_options'] as $option => $value) {
                if (is_string($option)) {
                    // Suppress warnings here
                    // Ignore it if it's not a valid constant
                    $option = @constant(strtoupper($option));
                    if ($option === null)
                        continue;
                }
                mysqli_options($this->_connection, $option, $value);
            }
        }

				// Check for SSL connection
				if ( isset($this->_config['ssl']['enabled']) && $this->_config['ssl']['enabled'] ) {
					mysqli_ssl_set($this->_connection, null, null, $this->_config['ssl']['ca_cert'], null, null);

					// Suppress connection warnings here.
					// Throw an exception instead.
					$isConnected = @mysqli_real_connect($this->_connection, 
									$this->_config['host'], $this->_config['username'], 
									$this->_config['password'], $this->_config['dbname'], $port, $socket, MYSQLI_CLIENT_SSL);
				} else {

					// Suppress connection warnings here.
					// Throw an exception instead.
					$isConnected = @mysqli_real_connect($this->_connection, 
									$this->_config['host'], $this->_config['username'], 
									$this->_config['password'], $this->_config['dbname'], $port,$socket);
				}
        
        if ($isConnected === false || mysqli_connect_errno()) {
            $this->closeConnection();
            // Throw exception with mysql error
            throw new Exception(
                    'Mysqli connection failed with following error - ' .
                             mysqli_connect_error());
        }
        
        if (! empty($this->_config['charset'])) {
            mysqli_set_charset($this->_connection, $this->_config['charset']);
        } else {
            mysqli_set_charset($this->_connection, "utf8");
        }
    }

    /**
     * Connect to pdo driver.
     * Check for pdo extenstion
     * and connect to driver using database params
     *
     * @access private
     * @param
     *            void
     * @return void
     * @throws Exception
     */
    private function _connectPdoDriver ()
    {
        if (! extension_loaded('pdo')) {
            throw new Exception('The PDO extension is required for this adapter but the extension is not loaded');
        }
        // connect to database
        ! empty($this->_config['socket']) ? $socket = $this->_config['socket'] : $socket = null;
        
        if (isset($this->_config['port'])) {
            $port = (integer) $this->_config['port'];
        } else {
            $port = self::DEFAULT_MYSQL_PORT;
        }

        // Suppress connection warnings here.
        // Throw an exception instead.
        $dsn = 'mysql:host='.  $this->_config['host'] . ';dbname='.$this->_config['dbname'];

        if (! empty($this->_config['charset'])) {
            $dsn .= ';charset='.$this->_config['charset'];
            mysqli_set_charset($this->_connection, $this->_config['charset']);
        } else {
            $dsn .= ';charset=utf8';
        }
        $options = array();
		// Check for SSL connection
        if ( isset($this->_config['ssl']['enabled']) && $this->_config['ssl']['enabled'] ) {
			$options = array(
				PDO::MYSQL_ATTR_SSL_CA => $this->_config['ssl']['ca_cert']
			);
		}
		$this->_connection = new PDO($dsn, $this->_config['username'], $this->_config['password'], $options);
        if ($this->_connection === false) {
            $errorMessage = PDO::errorInfo();
            $this->closeConnection();
            // Throw exception with mysql error
            throw new Exception('PDO connection failed with following error - ' . $errorMessage[3]);
        }
        $this->_connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    }
    /**
     * Creates a connection to the database.
     * We check for active drivers and create connection
     * on the basis of active drivers
     *
     * @access private
     * @param void
     * @return void
     * @throws Exception
     */
    protected function _connect ()
    {
        if ($this->_connection) {
            return ;
        }
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            $this->_connectMysqliDriver();
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            $this->_connectPdoDriver();
        }else{
            throw new Exception('Current active database driver is not supported by Noobh Framework');
        }

    }

    /**
     * Quote a raw string.
     *
     * @param mixed $value
     *            Raw string
     *            
     * @return string Quoted string
     */
    protected function _quote ($value)
    {
        if (is_int($value) || is_float($value)) {
            return $value;
        }
        $this->_connect();
        return "'" . $this->_connection->real_escape_string($value) . "'";
    }   
    
    /**
     * Parse params and validate sql for query and params binded
     * 
     * @param string $sql            
     * @return void
     */
    protected function _parseParameters ($sql)
    {
        $sql = $this->_stripQuoted($sql);
        
        // split into text and params
        $this->_sqlSplit = preg_split('/(\?|\:[a-zA-Z0-9_]+)/', $sql, - 1, 
                PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        
        // map params
        $this->_sqlParam = array();
        foreach ($this->_sqlSplit as $key => $val) {
            if ($val == '?') {
                if ($this->supportsParameters('positional') === false) {
                    throw new Exception("Invalid bind-variable position '$val'");
                }
            } else 
                if ($val[0] == ':') {
                    if ($this->supportsParameters('named') === false) {
                        throw new Exception("Invalid bind-variable name '$val'");
                    }
                }
            $this->_sqlParam[] = $val;
        }
        
        // set up for binding
        $this->_bindParam = array();
    }

    /**
     * Remove parts of a SQL string that contain quoted strings
     * of values or identifiers.
     *
     * @param string $sql            
     * @return string
     */
    protected function _stripQuoted ($sql)
    {
        // get the character for delimited id quotes,
        // this is usually " but in MySQL is `
        $d = $this->_quoteIdentifier('a');
        $d = $d[0];
        
        // get the value used as an escaped delimited id quote,
        // e.g. \" or "" or \`
        $de = $this->_quoteIdentifier($d);
        $de = substr($de, 1, 2);
        $de = str_replace('\\', '\\\\', $de);
        
        // get the character for value quoting
        // this should be '
        $q = $this->_quote('a');
        $q = $q[0];
        
        // get the value used as an escaped quote,
        // e.g. \' or ''
        $qe = $this->_quote($q);
        $qe = substr($qe, 1, 2);
        $qe = str_replace('\\', '\\\\', $qe);
        
        // get a version of the SQL statement with all quoted
        // values and delimited identifiers stripped out
        // remove "foo\"bar"
        $sql = preg_replace("/$q($qe|\\\\{2}|[^$q])*$q/", '', $sql);
        // remove 'foo\'bar'
        if (! empty($q)) {
            $sql = preg_replace("/$q($qe|[^$q])*$q/", '', $sql);
        }
        
        return $sql;
    }

    /**
     * Quote an identifier.
     *
     * @param string $value
     *            The identifier or expression.
     * @param boolean $auto
     *            If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
     * @return string The quoted identifier and alias.
     */
    protected function _quoteIdentifier ($value, $auto = false)
    {
        if ($auto === false || $this->_autoQuoteIdentifiers === true) {
            $q = '"';
            return ($q . str_replace("$q", "$q$q", $value) . $q);
        }
        return $value;
    }
    
    
    /**
     * Binds a parameter to the specified variable name.
     *
     * @param mixed $parameter
     *            Name the parameter, either integer or string.
     * @param mixed $variable
     *            Reference to PHP variable containing the value.
     * @param mixed $type
     *            OPTIONAL Datatype of SQL parameter.
     * @param mixed $length
     *            OPTIONAL Length of SQL parameter.
     * @param mixed $options
     *            OPTIONAL Other options.
     * @return bool
     * @throws Exception
     */
    protected function _bindParam ($parameter, &$variable, $type = null,
            $length = null, $options = null)
    {
        return true;
    }
    /**
     * Executes a prepared statement.
     *
     * @param array $params
     *            OPTIONAL Values to bind to parameter placeholders.
     * @return bool
     * @throws Exception
     */
    private function _execute (array $params = null)
    {
        if (! $this->_stmt) {
            return false;
        }
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            // if no params were given as an argument to execute(),
            // then default to the _bindParam array
            if ($params === null) {
                $params = $this->_bindParam;
            }
            // send $params as input parameters to the statement
            if ($params) {
                array_unshift($params, str_repeat('s', count($params)));
                $stmtParams = array();
                foreach ($params as $k => &$value) {
                    $stmtParams[$k] = &$value;
                }
                call_user_func_array(array($this->_stmt, 'bind_param'), $stmtParams);
            }
        
            // execute the statement
            $retval = $this->_stmt->execute();
            if ($retval === false) {
                throw new Exception(
                        "Query statement failed with error : " . $this->_stmt->error .
                        '[Mysqli - ]', $this->_stmt->errno);
            }
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            $retval = $this->_stmt->execute($params);
        }
        return $retval;        
       /* // retain metadata
        if ($this->_meta === null) {
            $this->_meta = $this->_stmt->result_metadata();
            if ($this->_stmt->errno) {
                throw new Exception(
                        "Mysqli statement metadata error: " . $this->_stmt->error,
                        $this->_stmt->errno);
            }
        }
        // statements that have no result set do not return metadata
        if ($this->_meta !== false) {
            // get the column names that will result
            $this->_keys = array();
            foreach ($this->_meta->fetch_fields() as $col) {
                $this->_keys[] = $col->name;
            }
            // set up a binding space for result variables
            $this->_values = array_fill(0, count($this->_keys), null);
    
            // set up references to the result binding space.
            // just passing $this->_values in the call_user_func_array()
            // below won't work, you need references.
            $refs = array();
            foreach ($this->_values as $i => &$f) {
                $refs[$i] = &$f;
            }
            $this->_stmt->store_result();
            // bind to the result variables
            call_user_func_array(array($this->_stmt, 'bind_result'),
            $this->_values);
        }
        return $retval;*/
    }
    /**
     * Returns the symbol the adapter uses for delimiting identifiers.
     * 
     * @todo: Need to make this dynamic for other drivers
     *  
     * @return string
     */
    public function getQuoteIdentifierSymbol ()
    {
        return "`";
    }

    /**
     * Test if a connection is active
     *
     * @return boolean
     */
    public function isConnected ()
    {
        return ((bool) ($this->_connection instanceof mysqli));
    }

    /**
     * Force the connection to close.
     *
     * @return void
     */
    public function closeConnection ()
    {
        if ($this->isConnected()) {
            $this->_connection->close();
        }
        $this->_connection = null;
    }

    /**
     * Prepare a statement and return a PDOStatement-like object.
     *
     * @param string $sql
     *            SQL query
     * @return mysqli_stmt
     */
    public function prepare ($sql)
    {
        if($this->_activeDriver == self::DRIVER_MYSQLI){
           //Removing validation for bind params due to performence issue
            // $this->_parseParameters($sql);
            $mysqli = $this->getConnection();
            $this->_stmt = $mysqli->prepare($sql);
            if ($this->_stmt === false || $mysqli->errno) {
                throw new Exception("Mysqli prepare error: " . $mysqli->error, $mysqli->errno);
            }
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            $pdo = $this->getConnection();
            $this->_stmt = $pdo->prepare($sql);
        }
        return $this->_stmt;
    }

    /**
     * Gets the last ID generated automatically by an IDENTITY/AUTOINCREMENT
     * column.
     *
     * As a convention, on RDBMS brands that support sequences
     * (e.g. Oracle, PostgreSQL, DB2), this method forms the name of a sequence
     * from the arguments and returns the last id generated by that sequence.
     * On RDBMS brands that support IDENTITY/AUTOINCREMENT columns, this method
     * returns the last value generated for such a column, and the table name
     * argument is disregarded.
     *
     * MySQL does not support sequences, so $tableName and $primaryKey are
     * ignored.
     *
     * @param string $tableName
     *            OPTIONAL Name of table.
     * @param string $primaryKey
     *            OPTIONAL Name of primary key column.
     * @return string
     * @todo Return value should be int?
     */
    public function lastInsertId ($tableName = null, $primaryKey = null)
    {
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            $mysqli = $this->_connection;
            return (string) $mysqli->insert_id;
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            $pdo = $this->_connection;
            return (string) $pdo->lastInsertId();
        }
    }


		/**
		* Gets the number of affected rows in a previous MySQL operation
		*
		* @return integer
		*/
		public function affectedRows ()
		{
			$mysqli = $this->_connection;
			return (string) $mysqli->affected_rows;
		}

    /**
     * Check if the adapter supports real SQL parameters.
     *
     * @param string $type
     *            'positional' or 'named'
     * @return bool
     */
    public function supportsParameters ($type)
    {
        switch ($type) {
            case 'positional':
                return true;
            case 'named':
            default:
                return false;
        }
    }

    /**
     * Executes a prepared statement.
     *
     * @param array $params OPTIONAL Values to bind to parameter placeholders.
     * @return bool
     */
    public function execute (array $params = null)
    {
        return $this->_execute($params);
    }
    
    /**
     * Return statement object 
     * 
     * Mysqli_statement, Pdo_statement etc
     * 
     * @access public
     * @param void
     * @return {Object}
     */
    public function getStatement(){
        return $this->_stmt;
    }
    
    /**
     * Fetch result as array
     *
     * @todo: Need to override different statements
     * and return the results
     *
     * @access public
     * @param void
     * @return {array}
     */
    public function fetchAll(){
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            return $this->_stmt->get_result()->fetch_all();
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            return $this->_stmt->fetchAll();
        }
    }
    
    /**
     * Fetch result as associative array
     *
     * @todo: Need to override different statements
     * and return the results
     *
     * @access public
     * @param void
     * @return {array}
     */
    public function fetchAssoc(){
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            return $this->_stmt->get_result()->fetch_all(MYSQLI_ASSOC);
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            return $this->_stmt->fetchAll(PDO::FETCH_ASSOC);
        }
    } 
    
    /**
     * Begin SQL transaction
     *
     * @todo: Support mysqli and pdo
     * 
     * @access public
     * @param void
     * @return void
     */
    public function beginTransaction(){
        if($this->_activeDriver == self::DRIVER_MYSQLI){
            $this->getConnection()->autocommit(FALSE);
        }else if($this->_activeDriver == self::DRIVER_PDO_MYSQLI){
            $this->getConnection()->beginTransaction();
        }
    }
    
    /**
     * Commit SQL transaction
     *
     * @todo: Support mysqli and pdo
     * 
     * @access public
     * @param void
     * @return void
     */
    public function commit(){
        $this->getConnection()->commit();
    }
    
    /**
     * Rollback SQL transaction
     *
     * @todo: Support mysqli and pdo
     *
     * @access public
     * @param void
     * @return void
     */
    public function rollBack(){
        $this->getConnection()->rollback();
    }
    
}
